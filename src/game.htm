<!DOCTYPE html>
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>TARDQUEST</title>
    <style>
        /* ===== Scrollbar CSS ===== */
        /* Firefox */
        * {
            scrollbar-width: thin;
            scrollbar-color: #fff #000;
        }

        /* Chrome, Edge, and Safari */
        *::-webkit-scrollbar {
            width: 12px;
        }

        *::-webkit-scrollbar-track {
            background: #000;
        }

        *::-webkit-scrollbar-thumb {
            background-color: #000;
            border-radius: 0px;
            border: 0px solid #fff;
        }

        body {
            background: #000;
            color: #fff;
            font-family: monospace;
            white-space: pre;
            padding: 20px;
            display: flex;
            box-sizing: content-box;
        }

        a:visited,
        a:link {
            color: #fff;
        }

        #ui {
            display: flex;
        }

        #game {
            font-size: var(--viewport-font-size);
            white-space: pre-wrap;
            margin-bottom: auto;
            margin-top: var(--viewport-font-size);
            align-content: center;
        }

        #menu:not(.hidden) {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding-bottom: 10px;
        }

        #menuList {
            margin-bottom: auto;
            padding-left: 1em;
        }

        #menuList,
        #menuSelectionDescription {
            flex-grow: 1;
            white-space: pre-wrap;
        }

        #menuLanding,
        #menuSelectionDescription {
            padding: 0 1em;
        }

        #menuList::before,
        #menuSelectionDescription::before {
            display: block;
            text-align: center;
        }

        #menuLanding {
            display: flex;
            flex-direction: column;
            white-space: pre-wrap;
            min-height: 8em;
        }

        #menuLanding > .title {
            margin: 0 auto 1em;
            letter-spacing: 1ch;
        }

        #animation:not(.hidden) {
            white-space: pre;
            overflow: hidden;
            text-align: initial;
            width: 100%;
        }

        #viewportContainer {
            --viewport-font-size: 13px;

            position: absolute;
            /* or absolute/fixed if you want to float it */

            left: 250px;
            top: 140px;
            border: 2px solid #fff;
            padding-top: 10px;
            padding-left: 4px;
            padding-right: 4px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            width: 360px;
            height: 339px;
            /* Match or exceed #game's min-height */
            overflow: hidden;
            box-sizing: content-box;
            align-items: center;
            justify-content: space-between;
        }


        #sidePanel {
            margin-left: 0px;
            display: flex;
            flex-direction: column;
        }
        #partylist {
            height: 90px;
            width: 348px;
            position: absolute;
            border: 2px solid #fff;
            top: 489px;
            left: 250px;
            padding: 10px;
            text-overflow: ellipsis;
            word-wrap: break-word;
            white-space: pre-wrap;
            overflow-y: auto;
            justify-content: space-between;
        }

        #battleLog,
        #minimap {
            background: #000;
            border: 2px solid #fff;
            padding: 10px;
            width: 570px;
            height: auto;
        }

        #battleLog {
            height: 90px;
            text-overflow: ellipsis;
            word-wrap: break-word;
            white-space: pre-wrap;
            overflow-y: scroll;
        }

        #minimap {
            height: 166px;
            width: 216px;
            padding: 2px;
            white-space: pre;
            font-size: 12px;
            border-top: 0;
        }

        .hidden {
            display: none;
        }

        #inputBox {
            display: none;
            /* This ensures it's hidden initially */
        }

        #inputBox input {
            background-color: black;
            color: white;
            border: none;
            font-size: 13px;
            width: 210px;
            z-index: 9;
        }

        .menus {
            position: absolute;
            border: solid white 2px;
            border-top: 0;
            top: 314px;
            width: 212px;
            height: 163px;
            overflow: hidden;
            line-height: 0px;
            font-size: 10px;
            padding: 4px;
            padding-top: 9px;
        }

        #controls {
            height: 90px;
            width: 200px;
            position: absolute;
            border: 2px solid #fff;
            top: 489px;
            padding: 10px;
            text-overflow: ellipsis;
            word-wrap: break-word;
            white-space: pre-wrap;
            overflow: hidden;
            justify-content: space-between;
        }

        .player {
            color: #2aff00;
        }

        .wall {
            color: #e9ff00;
        }

        .explored {
            color: #fff;
        }

        .unexplored {
            color: #545454;
        }

        .exit {
            color: #f00;
        }

        .merchant {
            color: #f7f;
        }

        .gambler {
            color: #ffd700;
        }

        .muted {
            color: #666;
            text-decoration: line-through;
        }

        .tooExpensive {
            color: #f00;
        }

        .alignRight {
            text-align: right;
        }
        .friendly {
            color: #61C9F6;
        }
        .enemy {
            color: #EC4134;
        }
        .EXP {
            color: #6EBD70;
        }
        .LV {
            color: #6EBD70;
        }
        .BTC {
            color: #FAEB4A;
        }
        .HP {
            color: #F1483D;
        }
        .DEF {
            color: #1463BA;
        }
        .PRS {
            color: #A23AB4;
        }
        .action {
            color: #EC4134;
        }
  </style>
</head>
<body>
  <div class="menus">
        <a href="https://xxthemilkman69xx.neocities.org/dungeon/title.html">TITLE</a>  <a href="https://xxthemilkman69xx.neocities.org/dungeon/game.html">RESET</a>  <a href="#" id="musicToggle">Toggle Music</a>

        <p><strong>KEY</strong></p>
        <p><span class="player">↑</span> Player: It's you!</p>
        <p><span class="wall">#</span> Wall: It's a fucking wall</p>
        <p><span class="exit">E</span> Exit: Touch to descend further</p>
        <p><span class="merchant">M</span> Merchant: Sells you crap</p>
        <p><span class="gambler">G</span> Gambler: A shady shyster</p>
        <p>H Healing Tile: Heals you to max HP</p>
        <p><span class="unexplored">?</span> Undiscovered: Who knows?</p>
      </div>
  <div id="partylist"></div>
  <div id="controls"></div>
  <div id="viewportContainer">
    <div id="game"></div>
    <div id="animation" class="hidden"></div>
    <div id="menu" class="hidden">
        <div id="menuLanding"></div>
        <div id="menuList"></div>
        <div id="menuSelectionDescription"></div>
        <div class="alignRight">Press Escape to go back</div>
    </div>
  </div>
  <div id="ui">
    <div id="sidePanel">
      <div id="battleLog"></div>
      <div id="minimap"></div>
      <div id="inputBox">
        <input type="text" id="persuadeInput" placeholder="Say your piece...">
      </div>
    </div>
  </div>

    <script>
        const
            WIDTH = 30,
            HEIGHT = 11;
        const DIRECTIONS = ['N', 'E', 'S', 'W'];
        const DX = [0, 1, 0, -1];
        const DY = [-1, 0, 1, 0];
        let seenTiles = Array.from({
            length: HEIGHT
        }, () => Array(WIDTH).fill(false));
        let lastFloorBoostNotice = 0;
        const player = {
            x: 1,
            y: 1,
            bitcoins: 0,
            dir: 0,
            hp: 20,
            maxHp: 20,
            defense: 3,
            persuasion: 5,
            exp: 0,
            level: 1,
            inCombat: false,
            levelingUp: false,
            inventory: {
                canOfHamms: 2,
                cupOfLean: 2,
                torch: 2,
                brickOfC4: 2,
                dowsingRod: 2,
            },
            weapon: 'pointyStick',
            armor: 'graphicTee',
            inputDisabled: false,
        };

        const merchant = {
            isAlive: true,
            isActiveOnFloor: false,
            x: WIDTH - 2,
            y: HEIGHT - 2,
            items: [],
            say: function(str) {
                updateBattleLog(`<span class="merchant">&lt;MERCHANT&gt;</span> "${str}"`);
            },
            die: function() {
                this.isAlive = false;
                this.isActiveOnFloor = false;
                playSFX('scream');
                merchant.say('AIEEEEEEEEEEEEEE!');
                updateBattleLog('HOLY SHIT! The <span class="friendly">merchant</span> has been <span class="action">vaporized</span> into a bloody red mist!');
            },
            buy: function(type, key) {
                const merchandise = (type === 'item' ? items : (type === 'weapon' ? weapons : armor))?.[key];
                if (!merchandise) {
                    console.error(`${itemKey} doesn't exist!`);
                    return;
                }

                if (player.bitcoins < merchandise.price) {
                    merchant.say('Too bad, kid. Come back when you get some coin!');
                    return;
                }

                player.bitcoins -= merchandise.price;
                playSFX('kaching');

                if (type === 'item') {
                    player.inventory[key] = (player.inventory?.[key] || 0) + 1;
                } else {
                    player[type] = key;
                }

                const purchaseFlavorText = [
                    "HAHA! You won't regret it!",
                    "Don't forget: NO REFUNDS!",
                    "You won't find a better deal than this!",
                ];
                const merchantText = purchaseFlavorText[Math.floor(Math.random() * purchaseFlavorText.length)];
                merchant.say(merchantText);

                const merchandiseText = getArticle(merchandise.name) + merchandise.name;
                updateBattleLog(`You just bought ${merchandiseText}`);
            }
        };

        const gambler = {
            isAlive: true,
            isActiveOnFloor: false,
            x: WIDTH - 4,
            y: HEIGHT - 4,
            selectionIndex: 0,
            options: ['gamble', 'leave'],
            playPrice: 200,
            say: function(str) {
                updateBattleLog(`<span class="gambler">&lt;GAMBLER&gt;</span> "${str}"`);
            },
            die: function () {
                this.isAlive = false;
                this.isActiveOnFloor = false;
                // Award between 50 and 100 BTC for the slaughter. I guess that's one way to win
                const rewardBtc = (5 + Math.round(Math.random() * 5)) * 10;
                player.bitcoins += rewardBtc;
                playSFX('scream');
                gambler.say('AUGH!!');
                updateBattleLog(`The <span class="gambler">gambler</span> has been reduced to a confetti of shrapnel and bone! You find <span class="BTC">${rewardBtc} BTC</span> among the remains. Awesome!`);
            }
        };

        const enemies = [
            {
                id: "snailSentinel",
                name: "SNAIL SENTINEL",
                hp: 10,
                attack: [1, 4],
                bitcoins: 4,
            },
            {
                id: "stupidDog",
                name: "STUPID DOG",
                hp: 6,
                attack: [2, 5],
                bitcoins: 3,
            },
            {
                id: "wangRat",
                name: "WANG RAT",
                hp: 5,
                attack: [3, 5],
                bitcoins: 2,
            },
            {
                id: "keeperOfTheToiletBowl",
                name: "KEEPER OF THE TOILET BOWL",
                hp: 15,
                attack: [3, 7],
                bitcoins: 5,
            },
            {
                id: "mysteriousScooter",
                name: "MYSTERIOUS SCOOTER",
                hp: 12,
                attack: [3, 6],
                bitcoins: 4,
            },
            {
                id: "badassFlamingSkeleton",
                name: "BADASS FLAMING SKELETON",
                hp: 13,
                attack: [4, 9],
                bitcoins: 4,
            },
            {
                id: "fridgeOfForgottenLeftovers",
                name: "FRIDGE OF FORGOTTEN LEFTOVERS",
                hp: 20,
                attack: [2, 3],
                bitcoins: 3,
            },
            {
                id: "lughead",
                name: "LUGHEAD",
                hp: 18,
                attack: [2, 6],
                bitcoins: 4,
            },
            {
                id: "pissedOffPoultry",
                name: "PISSED-OFF POULTRY",
                hp: 7,
                attack: [2, 5],
                bitcoins: 2,
            },
            {
                id: "krampusElf",
                name: "KRAMPUS ELF",
                hp: 7,
                attack: [3, 4],
                bitcoins: 4,
            },
        ];
        const defeatMessages = [
          "was beaten to a fucking pulp!",
          "had their bollocks slammed against the hard concrete wall!",
          "got their face scraped along the floor!",
          "died from a nosebleed. Alright then?",
          "was pulverized before they could activate ther anti-retard orbital laser.",
          "pancaked their diaper and died from embarassment. Gross.",
          "left the server.",
          "picked their nose, and died picking their nose.",
          "got bored and jumped down a 'bottomless' hole. You heard a scream, and the sound was absolutely not faint."
        ];

        const weapons = {
            pointyStick: {
                name: "POINTY STICK",
                description: "A stick that fell off of a tree somewhere",
                damage: {
                    base: 2,
                    randomMultiplier: 5,
                },
                price: 20,
            },
            wiffleBallBat: {
                name: "WIFFLE BALL BAT",
                description: "A hollow bat made of plastic",
                damage: {
                    base: 3,
                    randomMultiplier: 6,
                },
                price: 50,
            },
            nunchucks: {
                name: "NUNCHUCKS",
                description: "Two pieces of wood connected by a chain",
                damage: {
                    base: 6,
                    randomMultiplier: 9,
                },
                price: 100,
            },
            atlatlSpear: {
                name: "ATLATL SPEAR",
                description: "A spear with a throwing lever",
                damage: {
                    base: 10,
                    randomMultiplier: 11,
                },
                price: 400,
            },
            bludgeoningMace: {
                name: "BLUDGEONING MACE",
                description: "A stick with a spikey metal ball at the end",
                damage: {
                    base: 10,
                    randomMultiplier: 14,
                },
                price: 500,
            },
        };

        const armor = {
            graphicTee: {
                name: "GRAPHIC TEE",
                description: "A t-shirt that says 'Normal people scare me'",
                defense: 1,
                price: 20,
            },
            barrelWithSuspenders: {
                name: "BARREL (with suspenders)",
                description: "An empty barrel that sort of covers your torso and legs. Smells like whisky too!",
                defense: 3,
                price: 50,
            },
            leatherArmor: {
                name: "LEATHER ARMOR",
                description: "The finest in leather, fitted with a tight top, codpiece, cat o' nine tails... (uh, are you sure this is actually armor?)",
                defense: 6,
                price: 150,
            },
            milaneseArmor: {
                name: "MILANESE ARMOR",
                description: "A classic suit of armor. Looks kind of like a Renaissance-era Robocop",
                defense: 12,
                price: 1000,
            },
        };

        const items = {
            canOfHamms: {
                name: "CAN OF HAMM'S",
                description: "A warm can of beer. Delicious..? Heals +5 HP",
                use: () => {
                    healPlayer(5);
                    updateBattleLog("You chug the can, filling your mouth with the flavor of boiled socks. +5 HP");
                },
                merchantStockChance: 0.9,
                price: 10,
            },
            cupOfLean: {
                name: "CUP OF LEAN",
                description: "A crusty styrofoam cup filled with a strange purple syrup. Heals +20 HP",
                use: () => {
                    healPlayer(20);
                    updateBattleLog("Your stomach feels nauseous, but your head feels great! +20 HP");
                },
                merchantStockChance: 0.5,
                price: 30,
            },
            dowsingRod: {
                name: "DOWSING ROD",
                description: "A Y-shaped stick. Reveals the exit of the current floor",
                use: () => {
                    useDowsingRod();
                    updateBattleLog("The exit has been revealed!");
                },
                merchantStockChance: 0.8,
                price: 20,
            },
            torch: {
                name: "TORCH",
                description: "An unlit torch. Using it will reveal the map of the current floor",
                use: () => {
                    revealMap();
                    playSFX('torch');
                    updateBattleLog("Lo, the way has been made clear!");
                },
                merchantStockChance: 0.8,
                price: 60,
            },
            brickOfC4: {
                name: "BRICK OF C-4",
                description: "An incendiary plastic explosive. Great for turning anything into nothing real quick",
                use: () => useC4(),
                merchantStockChance: 0.5,
                price: 300,
            },
        };

        function healPlayer(hp) {
            player.hp = Math.min(player.maxHp, player.hp + hp);
        }

        function useDowsingRod() {
            for (let y=0; y<MAP.length; y++) {
                for (let x=0; x<MAP[y].length; x++) {
                    if (MAP[y][x] === 'E') {
                        revealMapSpot(x, y, 1);

                        // Since there's only one exit per floor, we can render and exit early
                        render();
                        return;
                    }
                }
            }
        }

        function revealMapSpot(x, y, radius) {
            for (let py=y-radius; py<=y+radius; py++) {
                for (let px=x-radius; px<=x+radius; px++) {
                    if (typeof MAP[py]?.[px] !== 'undefined') {
                        seenTiles[py][px] = true;
                    }
                }
            }
        }

        function revealMap() {
            seenTiles = seenTiles.map((col) => col.map((cell) => true));
            render();
        }

        function useC4() {
            playSFX('explosion');

            if (player.inCombat) {
                const dmg = Math.max(20, Math.round(Math.random() * 10) * 5);
                currentEnemy.hp -= dmg;
                updateBattleLog(`You exploded the shit out of <span class="action">${currentEnemy.name}</span> for <span class="HP">${dmg} HP</span>!!!`);
                endOfPlayerTurn();
            } else {
                updateBattleLog('<span class="action">KABOOM!</span> The dungeon walls crumble like charred toast!');
                explodePath();
                render();
            }
        }

        function explodePath() {
            let xMin = player.x, xMax = player.x,
                yMin = player.y, yMax = player.y;

            switch (DIRECTIONS[player.dir]) {
                case 'N':
                    xMin--;
                    xMax++;
                    yMin -= 3;
                    break;
                case 'E':
                    yMin--;
                    yMax++;
                    xMax += 3;
                    break;
                case 'S':
                    xMin--;
                    xMax++;
                    yMax += 3;
                    break;
                case 'W':
                    yMin--;
                    yMax++;
                    xMin -= 3;
                    break;
            }

            for (let y=yMin; y<=yMax; y++) {
                for (let x=xMin; x<=xMax; x++) {
                    breakMap(x, y);
                }
            }
        }

        function breakMap(x, y) {
            if (coordsInBounds(x, y)) {
                if (MAP[y][x] === '#') {
                    MAP[y][x] = '.';
                }

                const killedMerchant =
                    merchant.isAlive &&
                    merchant.isActiveOnFloor &&
                    merchant.x === x && merchant.y === y;
                if (killedMerchant) {
                    merchant.die();
                }

                const killedGambler =
                    gambler.isAlive &&
                    gambler.isActiveOnFloor &&
                    gambler.x === x && gambler.y === y;
                if (killedGambler) {
                    gambler.die();
                }

                seenTiles[y][x] = true;
            }
        }

        function setMerchantWares() {
            const itemKeys = Object.keys(items);
            if (itemKeys.length === 0) {
                console.error("Where the fuck did the items go?");
                return;
            }

            do {
                merchant.items = [];
                itemKeys.forEach((key) => {
                    if (Math.random() < items[key].merchantStockChance) {
                        merchant.items.push(key);
                    }
                });
            } while (merchant.items.length === 0);
        }

        const sfx = {
            footstep: new Audio('https://files.catbox.moe/o0ka4u.wav'),
            turn: new Audio('https://files.catbox.moe/heur5b.wav'),
            attack: new Audio('https://files.catbox.moe/0ggtsm.wav'),
            run: new Audio('https://files.catbox.moe/f6eyem.wav'),
            persuade: new Audio('https://files.catbox.moe/e7n7vo.wav'),
            explosion: new Audio('https://files.catbox.moe/jhaqzp.mp3'),
            scream: new Audio('https://files.catbox.moe/j2oegh.mp3'),
            kaching: new Audio('https://files.catbox.moe/02ht6d.mp3'),
            torch: new Audio('https://files.catbox.moe/b2jzsn.mp3'),
            gamble: new Audio('https://files.catbox.moe/mo9o5z.mp3'),
            inventoryOpen: new Audio('https://files.catbox.moe/8cf12i.mp3'),
            uiOption: new Audio('https://files.catbox.moe/h34402.wav'),
            uiSelect: new Audio('https://files.catbox.moe/2cvmq8.wav'),
            uiCancel: new Audio('https://files.catbox.moe/5doy28.wav'),
        };

        const music = {
            exploration: new Audio('https://files.catbox.moe/hmgkva.wav'),
            battleTracks: [
                new Audio('https://files.catbox.moe/3ajd4i.mp3'), // battle1.mp3
                new Audio('https://files.catbox.moe/ua8mbs.mp3'), // battle2.mp3
            ],
            current: null
        };

        music.exploration.loop = true;
        music.battleTracks.forEach(track => track.loop = true);


        let currentMusic = null;
        let currentEnemy = null;
        let party = [];
        let gameOver = false;
        let awaitingPersuasionText = false;
        let speakingOutsideCombat = false;
        let battleLog = [];
        let floor = 1;
        let MAP = [];
        let exit = {
            x: WIDTH - 2,
            y: HEIGHT - 2
        };

        function generateMap() {
            setExitPosition();

            // Fill in walls
            for (let y = 0; y < HEIGHT; y++) {
                MAP[y] = [];
                for (let x = 0; x < WIDTH; x++) {
                    MAP[y][x] = '#';
                    seenTiles[y][x] = false;
                    // Uncomment this to see the full map
                    // seenTiles[y][x] = true;
                }
            }

            // Carve out a path
            let position = {
                x: player.x,
                y: player.y,
            };

            let stack = null;
            do {
                stack = carvePath([position]);
            } while (stack === null);

            for (let i in stack) {
                MAP[stack[i].y][stack[i].x] = '.';
            }

            for (let i=0; i<10; i++) {
                dissolveMap();
            }

            MAP[player.y][player.x] = '.';
            MAP[exit.y][exit.x] = 'E';

            merchant.isActiveOnFloor = merchant.isAlive && Math.random() < 0.25;
            if (merchant.isActiveOnFloor) {
                setMerchant();
            }

            gambler.isActiveOnFloor = gambler.isAlive && Math.random() < 0.25;
            if (merchant.isActiveOnFloor) {
                setGambler();
            }
        }

        /**
         * Places the exit based on the player's current position
         *
         * This will set the exit in either the opposite side or opposite corner
         * of where the player currently resides on the map
         */
        function setExitPosition() {
            const margin = 2;
            const possiblePositions = [['x', 'y'], ['x'], ['y']];
            const positions = possiblePositions[
                Math.floor(Math.random() * possiblePositions.length)
            ];

            for (let p in positions) {
                if (positions[p] === 'x') {
                    const exitOffsetX = Math.round(Math.random() * Math.round(WIDTH / 10));
                    if (player.x < WIDTH / margin) {
                        // Player is on the left side of the map
                        // Put the exit on the right
                        exit.x = WIDTH - margin - exitOffsetX;
                    } else {
                        // Player is on the right side of the map
                        // Put the exit on the left
                        exit.x = margin + exitOffsetX;
                    }
                } else {
                    const exitOffsetY = Math.round(Math.random() * Math.round(HEIGHT / 10));
                    if (player.y < HEIGHT / margin) {
                        // Player is at the top of the map
                        // Put the exit on the bottom
                        exit.y = HEIGHT - margin - exitOffsetY;
                    } else {
                        // Player is at the bottom of the map
                        // Put the exit on the top
                        exit.y = margin + exitOffsetY;
                    }
                }
            }
        }

        function setMerchant() {
            setMerchantWares();
            setMerchantPosition();
        }

        function setMerchantPosition() {
            let attempts = 0;

            do {
                const x = Math.floor(Math.random() * WIDTH);
                const y = Math.floor(Math.random() * HEIGHT);

                const isEmptySpace =
                    MAP[y][x] === '.' &&
                    (y !== exit.y && x !== exit.x) &&
                    (y !== player.y && x !== player.x);

                if (isEmptySpace) {
                    merchant.x = x;
                    merchant.y = y;
                    return;
                }
            } while (attempts++ < 1000);

            // If we couldn't place the merchant, don't activate the merchant
            console.warn(`Unable to place the merchant after ${attempts} attempts. The merchant will be deactivated for this floor`);
            merchant.isActiveOnFloor = false;
        }

        function setGambler() {
            let attempts = 0;

            do {
                const x = Math.floor(Math.random() * WIDTH);
                const y = Math.floor(Math.random() * HEIGHT);

                const isMerchantSpace =
                    merchant.isActiveOnFloor &&
                    y === merchant.y &&
                    x === merchant.x;

                const isEmptySpace =
                    MAP[y][x] === '.' &&
                    (y !== exit.y && x !== exit.x) &&
                    (y !== player.y && x !== player.x) &&
                    !isMerchantSpace;

                if (isEmptySpace) {
                    gambler.x = x;
                    gambler.y = y;
                    return;
                }
            } while (attempts++ < 1000);

            // If we couldn't place the gambler, don't activate the gambler
            console.warn(`Unable to place the gambler after ${attempts} attempts. The gambler will be deactivated for this floor`);
            gambler.isActiveOnFloor = false;
        }

        function carvePath(stack) {
            const direction = Math.random() < 0.5 ? 'horizontal' : 'vertical';
            const step = Math.random() < 0.5 ? -1 : 1;
            let lastPosition = stack[stack.length - 1];

            for (let i=0; i<2; i++) {
                const nextPosition = {
                    x: lastPosition.x + (direction === 'horizontal' ? step : 0),
                    y: lastPosition.y + (direction === 'vertical' ? step : 0),
                };

                const atMapEdge =
                    nextPosition.x === 0 ||
                    nextPosition.y === 0 ||
                    nextPosition.x === WIDTH - 1 ||
                    nextPosition.y === HEIGHT - 1;

                if (atMapEdge) {
                    return null;
                }

                const alreadyVisited = stack.find((cell) =>
                    cell.x === nextPosition.x && cell.y === nextPosition.y
                );
                if (alreadyVisited) {
                    return null;
                }

                stack.push(nextPosition);

                const reachedEnd =
                    nextPosition.x === exit.x &&
                    nextPosition.y === exit.y;

                if (reachedEnd) {
                    return stack;
                }

                lastPosition = nextPosition;
            }

            let result;
            for (let i=0; i<100; i++) {
                result = carvePath(stack);
                if (result) {
                    break;
                }
            }

            return result;
        }

        function dissolveMap() {
            let dissolvePoints = [];
            for (let y = 2; y < HEIGHT - 2; y++) {
                for (let x = 2; x < WIDTH - 2; x++) {
                    const isDissolvePoint = MAP[y][x] === '#' && (
                        (MAP[y - 1][x] === '#' ? 1 : 0) +
                        (MAP[y + 1][x] === '#' ? 1 : 0) +
                        (MAP[y][x - 1] === '#' ? 1 : 0) +
                        (MAP[y][x + 1] === '#' ? 1 : 0)
                    ) === 3;

                    if (isDissolvePoint) {
                        dissolvePoints.push({x, y});
                    }
                }
            }

            const totalPointsToDissolve = Math.floor(dissolvePoints.length / 2);
            if (totalPointsToDissolve < 1) {
                return;
            }

            for (let i = 0; i < totalPointsToDissolve; i++) {
                const index = Math.floor(Math.random() * dissolvePoints.length);
                const dissolvePoint = dissolvePoints[index];
                MAP[dissolvePoint.y][dissolvePoint.x] = '.';
                dissolvePoints = dissolvePoints.splice(index, 1);
            }
        }

        function updateSeenTiles() {
            seenTiles[player.y][player.x] = true;
            for (let i = 0; i < 4; i++) {
                let nx = player.x + DX[i];
                let ny = player.y + DY[i];
                if (nx >= 0 && ny >= 0 && nx < WIDTH && ny < HEIGHT) {
                    seenTiles[ny][nx] = true;
                }
            }
        }

        function drawMinimap() {
            let out = '';
            for (let y = 0; y < HEIGHT; y++) {
                for (let x = 0; x < WIDTH; x++) {
                    let tile = '';
                    let tileClass = '';
                    if (x === player.x && y === player.y) {
                        const arrow = ['↑', '→', '↓', '←'][player.dir];
                        tile = arrow;
                        tileClass = 'player';
                    } else if (!seenTiles[y][x]) {
                        tile = '?';
                        tileClass = 'unexplored';
                    } else {
                        if (isMerchantTile(x, y)) {
                            tile = 'M';
                            tileClass = 'merchant';
                        } else if (isGamblerTile(x, y)) {
                            tile = 'G';
                            tileClass = 'gambler';
                        } else {
                            switch (MAP[y][x]) {
                                case '#':
                                    tile = '#';
                                    tileClass = 'wall';
                                    break;
                                case 'E':
                                    tile = 'E';
                                    tileClass = 'exit';
                                    break;
                                default:
                                    tile = '.';
                                    tileClass = 'explored';
                            }
                        }
                    }
                    out += `<span class="${tileClass}">${tile}</span>`;
                }
                out += '<br>';
            }
            document.getElementById('minimap').innerHTML = out;
        }

        function isMerchantTile(x, y) {
            return merchant.isActiveOnFloor && x === merchant.x && y === merchant.y;
        }

        function isGamblerTile(x, y) {
            // The gambler won't appear if the player is broke
            return gambler.isActiveOnFloor && player.bitcoins >= gambler.playPrice && x === gambler.x && y === gambler.y;
        }

        function updateBattleLog(entry) {
            battleLog.push(entry);
            if (battleLog.length > 50) {
                battleLog.shift();
            }

            const logContainer = document.getElementById("battleLog");
            logContainer.innerHTML = [...battleLog]
                .slice()
                .reverse()
                .map((msg, i) => {
                    const lightness = 100 - (i * 15); // Fade effect
                    const color = `hsl(0, 0%, ${Math.max(lightness, 50)}%)`; // Prevent it from getting too dark
                    return `<div style="color: ${color};">${msg}</div>`;
                })
                .join("");
        }

        function playMusic(type) {
            if (currentMusic === type) return;
            if (music.current) {
                music.current.pause();
                music.current.currentTime = 0;
            }

            if (type === 'exploration') {
                music.exploration.play().catch(err => console.error("Music error:", err));
                music.current = music.exploration;
            } else if (type === 'battle') {
                const randomTrack = music.battleTracks[Math.floor(Math.random() * music.battleTracks.length)];
                randomTrack.currentTime = 0;
                randomTrack.play().catch(err => console.error("Music error:", err));
                music.current = randomTrack;
            }

            currentMusic = type;
        }


        function playSFX(name) {
            if (!sfx[name]) {
                console.error("SFX not found", { name });
                return;
            }

            sfx[name].currentTime = 0;
            sfx[name].play();
        }

        function wallSlice(d) {
            return {
                3: "||     /#####\\     ||\n",
                2: "||    |#######|    ||\n",
                1: "||   |#########|   ||\n"
            } [d];
        }

        function corridorSlice(d) {
            return {
                3: "||     /     \\     ||\n",
                2: "||    |       |    ||\n",
                1: "||   |         |   ||\n"
            } [d];
        }

        function exitSlice(d) {
            return {
                3: "||     /  E  \\     ||\n",
                2: "||    |   E   |    ||\n",
                1: "||   |    E    |   ||\n"
            } [d];
        }

        function healSlice(d) {
            return {
                3: "||     /  +  \\     ||\n",
                2: "||    |   +   |    ||\n",
                1: "||   |    +    |   ||\n"
            } [d];
        }


        function getEnemyArt() {
            switch (currentEnemy?.id) {
                case "snailSentinel":
                    return `




   ___   |_|
  /   \\_/@ @
__\\_______^/
`;
                case "stupidDog":
                    return `




/\\__/\\
|@  @|
|(00)|
 )vv(
`;
                case "keeperOfTheToiletBowl":
                    return `



   _______
  |       |
  |_______|=)
 -----------         ^
 |         |    O____|
 \\_________/   /|    |
    |   |       |    |
    |___|      / \\   |
`;
                case "mysteriousScooter":
                    return `





       [~~]=====[~~]
            ||
            ||
            ||
            ||
(O)======(O)===O)
`;
                case "badassFlamingSkeleton":
                    return `
      |\\ |\\ |\\ |\\ |\\ /| /|
          _______         /|
    |\\   /   \\   \\      /|
  |\\     | [ ]  [ ]        /|
    |\\   |        |          /|
         \\ \\=====/     //   /|
 |\\       \\______\\    ()/    /|
  |\\       ||        //   /|
     O==[==||==]====O      /|
|\\   || [==||==]       /| /|
  |\\ () [==||==]  /|  /| /|
`;
                case "wangRat":
                    return `




       ______
    (|/      \\|)
      \\O    o/___________________
     --\\-()-/--        __|__|__|_\\
        \\__/__________/
        _|  _|  _|  _|
`;

                case "fridgeOfForgottenLeftovers":
                    return `

            ___.---+.
       .--''       | '.
       |           |  |
       |     ______|  |
       |----'      |  |
       |       [==]|  |
       |           |  |
       |           |  |
       |___        |  |
           '---.___|.-'
`;

                case "lughead":
                    return `



            .--.
            |oO|
         ..-\\TT/-..
        '          '
        ( )      ( )
        ( |------| )
        'W . || . W'
          (__)(__)
`;

                case "pissedOffPoultry":
                    return `



    .        .--.
    |\\      .-:;
    : \\    < O |'
     \\ \\   ;    '.
      \\/\\-(    (. '
      (_)/ -_    ' ;
             '-; ;
            /|\\/|\\
`;

                case "krampusElf":
                    return `



             *
            / \\
        .-./___\\.-.
         \\/ o o \\/
         (__(_)__)
           / : \\
          (_|-|_)
          (__|__)
`;

                default:
                    return '';
            }
        }


        function render() {
            updateSeenTiles();
            drawMinimap();
            let output = "";

            // If the player is leveling up
            if (player.levelingUp) {
                output +=
                    "=== LEVEL UP! ===\nChoose a stat to increase:\nH: Max HP\nD: Defense\nP: Persuasion\n";
                document.getElementById('game').textContent = output;
                return;
            }

            // If the player is in combat
            if (player.inCombat) {
                              // Combat stats
                output +=
                    `<span class="LV">LV: ${player.level}</span> ` +
                    `<span class="EXP">EXP: ${player.exp}/${player.level * 10}</span> <span class="BTC">BTC: ${player.bitcoins}</span>\n` +
                    `<span class="HP">HP: ${player.hp}</span> ` +
                    `<span class="DEF">DEF: ${player.defense}</span> ` +
                    `<span class="PRS">PRS: ${player.persuasion}</span>`;
                output += `${getEnemyArt()}`;

                if (party.length > 0) {
                    let partyHTML = `<strong>Your Party:</strong><br>`;
                    party.forEach(member => {
                        partyHTML += `- <span class="friendly">${member.name}</span> <span class="HP">(HP: ${member.hp})</span><br>`;
                    });
                    document.getElementById("partylist").innerHTML = partyHTML;
                } else {
                    document.getElementById("partylist").innerHTML = '';
                }

                if (!awaitingPersuasionText) {
                    document.getElementById("controls").textContent =
                        "A:      Attack\nR:      Run\nP:      Persuade\nI:      Inventory";
                }

            } else {
                // Exploration stats (appear BEFORE wall slices now)
                output +=
                    `<span class="LV">LV: ${player.level}</span> ` +
                    `<span class="EXP">EXP: ${player.exp}/${player.level * 10}</span> <span class="BTC">BTC: ${player.bitcoins}</span>\n` +
                    `<span class="HP">HP: ${player.hp}</span> ` +
                    `<span class="DEF">DEF: ${player.defense}</span> ` +
                    `<span class="PRS">PRS: ${player.persuasion}</span>\n\n\n\n\n\n\n`;

                // Exploration view (wall slices)
                for (let d = 3; d >= 1; d--) {
                    let tx = player.x + DX[player.dir] * d;
                    let ty = player.y + DY[player.dir] * d;
                    let tile = getTile(tx, ty);
                    output += tile === '#' ? wallSlice(d) :
                        tile === 'E' ? exitSlice(d) :
                        tile === 'H' ? healSlice(d) :
                        corridorSlice(d);
                }

                // Logo
                output +=
                    "||                 ||\n||    Welcome to   ||\n++----TARDQUEST----++\n";

                // Party display
                if (party.length > 0) {
                    let partyHTML = `<strong>Your Party:</strong><br>`;
                    party.forEach(member => {
                        partyHTML += `- <span class="friendly">${member.name}</span> <span class="HP">(HP: ${member.hp})</span><br>`;
                    });
                    document.getElementById("partylist").innerHTML = partyHTML;
                } else {
                    document.getElementById("partylist").innerHTML = '';
                }

                // Controls
                document.getElementById("controls").textContent =
                    "↑/W:      Move Forward\n↓/S:      Move Backward\n←/A, →/D: Turn\nT:        Talk\nI:        Inventory";
            }

            // If the player is dead
            if (player.hp <= 0) {
                output += `\nGood job! <span class="action">You died</span> on <span class="action">floor ${floor}</span>`;
                gameOver = true;
                setTimeout(() => window.location.href = "https://xxthemilkman69xx.neocities.org/dungeon/title.html", 5000);
            }

            // Render the final output to the game screen
            document.getElementById('game').innerHTML = output; // Use innerHTML to ensure HTML is rendered
        }

        function isEmpty(obj) {
            for (let i in obj) {
                return false;
            }
            return true;
        }

        function getTile(x, y) {
            return !coordsInBounds(x, y) ? '#' : MAP[y][x];
        }

        function coordsInBounds(x, y) {
            return x >= 0 && x < WIDTH && y >= 0 && y < HEIGHT;
        }

        function move(direction) {
            if (player.inCombat || gameOver) {
                return;
            }

            playSFX('footstep');
            let nx, ny, randomEncounterChance;
            if (direction === 'forward') {
                nx = player.x + DX[player.dir];
                ny = player.y + DY[player.dir];
                randomEncounterChance = 0.25;
            } else {
                nx = player.x - DX[player.dir];
                ny = player.y - DY[player.dir];
                randomEncounterChance = 0.5;
            }

            const tile = getTile(nx, ny);
            if (tile !== '#') {
                player.x = nx;
                player.y = ny;
                if (isMerchantTile(nx, ny)) {
                    menu.open('merchant');
                } else if (isGamblerTile(nx, ny)) {
                    menu.open('gambler');
                } else if (tile === 'E') {
                    descend();
                } else if (tile === 'H') {
                    player.hp = player.maxHp;
                    MAP[ny][nx] = '.';
                    updateBattleLog('<span class="friendly">You healed to full HP!</span>');
                } else if (Math.random() < 0.2) {
                    MAP[ny][nx] = 'H';
                } else if (Math.random() < randomEncounterChance) {
                    startEncounter();
                }
            }
        }

        function turnLeft() {
            if (player.inCombat || gameOver) {
                return;
            }

            playSFX('turn');
            player.dir = (player.dir + 3) % 4;
        }

        function turnRight() {
            if (player.inCombat || gameOver) {
                return;
            }

            playSFX('turn');
            player.dir = (player.dir + 1) % 4;
        }

        function startEncounter() {
            // Pick a random enemy
            currentEnemy = structuredClone(
                enemies[Math.floor(Math.random() * enemies.length)]
            );

            // Scale enemy stats based on floor
            const floorBoost = Math.floor(floor / 2); // Scale every 2 floors
            if (floorBoost > 0) {
                currentEnemy.hp += floorBoost * 5; // +5 HP per scaling
                currentEnemy.attack = [
                    currentEnemy.attack[0] + (floorBoost * 3), // Adjust attack range based on floor scaling
                    currentEnemy.attack[1] + (floorBoost * 3)  // Adjust attack range based on floor scaling
                ];
                currentEnemy.bitcoins += floorBoost; // Increase Bitcoin drop based on floor scaling
            }

            player.inCombat = true;
            party.forEach(member => member.healedThisBattle = false);
            updateBattleLog(`A wild <span class="enemy">${currentEnemy.name}</span> appears!`);
            playMusic('battle');
        }


        function playerAttack() {
            if (!player.inCombat || awaitingPersuasionText) {
                return;
            }

            playSFX('attack');
            const playerWeapon = weapons[player.weapon];
            const dmg = Math.floor(Math.random() * playerWeapon.damage.randomMultiplier) + playerWeapon.damage.base;
            currentEnemy.hp -= dmg;
            updateBattleLog(`You deal ${dmg} HP to ${currentEnemy.name}`);
            endOfPlayerTurn();
        }

        function endOfPlayerTurn() {
            party.forEach(member => {
                if (!member.healedThisBattle && Math.random() < 0.2) {
                    let healed = Math.ceil(player.maxHp * 0.02);
                    player.hp = Math.min(player.maxHp, player.hp + healed);
                    member.healedThisBattle = true;
                    updateBattleLog(
                        `<span class="friendly">${member.name}</span> tended your wounds <span class="HP">(+${healed} HP)</span>`
                    );
                }
            });

            if (currentEnemy.hp <= 0) {
                const baseExp = 5;
                const floorBoost = Math.floor(floor / 2);
                const exp = baseExp + (floorBoost * 5); // +5 EXP per boost
                const bitcoinsEarned = currentEnemy.bitcoins;

                const randomMsg = defeatMessages[Math.floor(Math.random() * defeatMessages.length)];
                updateBattleLog(`${currentEnemy.name} ${randomMsg}`);
                updateBattleLog(`You gained <span class="EXP">+${exp}</span> EXP and <span class="BTC">${bitcoinsEarned} BTC</span>`);
                player.inCombat = false;
                player.bitcoins += bitcoinsEarned;
                currentEnemy = null;
                player.exp += exp;
                playMusic('exploration');
                party = party.filter(a => a.hp > 0);
                if (player.exp >= player.level * 10) {
                    player.levelingUp = true;  // Keep only the leveling-up flag
                    // Do NOT increment player.level here
                }
            } else {
                enemyAttack();
            }

            render();
        }

        function enemyAttack() {
            const targetAllies = party.filter(a => a.hp > 0);
            if (targetAllies.length && Math.random() < 0.5) {
                const target = targetAllies[Math.floor(Math.random() * targetAllies.length)];

                // Base damage
                let baseDamage = Math.floor(Math.random() * 5) + 1;

                // Boost damage based on the floor
                const floorBoost = Math.floor(floor / 2);  // Floor scaling every 2 floors
                baseDamage += floorBoost; // Increase base damage by the floorBoost

                // Calculate damage based on player's defense
                const playerArmor = armor[player.armor];
                const totalDefense = player.defense + (playerArmor ? playerArmor.defense : 0);

                let dmg = Math.max(1, Math.floor(baseDamage - totalDefense / 5));

                target.hp -= dmg;
                updateBattleLog(`<span class="enemy">${currentEnemy.name}</span> deals <span class="enemy">${dmg} HP</span> to your <span class="friendly">${target.name}</span>`);

                if (target.hp <= 0) {
                    updateBattleLog(`Your <span class="friendly">${target.name}</span> has been <span class="action">eviscerated</span>...`);
                }
            } else {
                // Same for the player, calculate the damage for the player
                let baseDamage = Math.floor(Math.random() * 5) + 1;

                // Boost damage based on the floor
                const floorBoost = Math.floor(floor / 2);  // Floor scaling every 2 floors
                baseDamage += floorBoost;

                // Calculate damage based on the player's defense
                const playerArmor = armor[player.armor];
                const totalDefense = player.defense + (playerArmor ? playerArmor.defense : 0);

                const dmg = Math.max(1, Math.floor(baseDamage - totalDefense / 5));
                player.hp -= dmg;

                updateBattleLog(`<span class="enemy">${currentEnemy.name}</span> deals <span class="HP">${dmg} HP</span> to <span class="friendly">you</span>`);

                if (player.hp <= 0) gameOver = true;
            }
        }



        function tryRun() {
            if (!player.inCombat || awaitingPersuasionText) {
                return;
            }

            playSFX('run');
            if (Math.random() < 0.5) {
                updateBattleLog("YOU: Gee willikers, I'm outta here!");
                player.inCombat = false;
                currentEnemy = null;
                playMusic('exploration');
            } else {
                updateBattleLog("Couldn't escape!");
                enemyAttack();
            }
            render();
        }

        function tryPersuade(e) {
            e?.preventDefault();
            playSFX('persuade');
            awaitingPersuasionText = true;

            // Show the input box
            const inputBox = document.getElementById("inputBox");
            const input = document.getElementById("persuadeInput");
            inputBox.style.display = "flex";
            input.value = "";

            // Delay the focus slightly to ensure it's applied after rendering
            setTimeout(() => {
                input.focus();
            }, 10);
        }



        document.getElementById("persuadeInput").addEventListener("keydown", e => {
            if (e.key === "Enter") {
                const message = e.target.value;
                updateBattleLog(`YOU: "${message}"`);
                e.target.value = "";
                awaitingPersuasionText = false;
                document.getElementById("inputBox").style.display = "none";

                // ======== Speaking Outside Combat ========
                if (speakingOutsideCombat) {
                    speakingOutsideCombat = false;

                    if (party.length > 0) {
                        const responder = party[Math.floor(Math.random() * party.length)];
                        const responses = [
                            "--you pull out your translator-- 'Wow! Please shut the fuck up.'",
                            "--you pull out your translator-- 'Just so you know, we're not even...'",
                            "--you pull out your translator-- 'You can't be fucking serious...'",
                            "--you pull out your translator-- 'I've come for your pickleeee...'",
                            "--you pull out your translator-- 'Hey that's cool and all, but have you ever played SpongeBob SquarePants: Revenge of the Flying Dutchman on the Sony PlayStation 2?",
                            "--they're too busy playing Burnout Revenge on the PS2--",
                            "--they're too busy sexting your mom--",
                            "--they pick their own nose, and then they pick YOUR nose...--",
                            "--you notice them scratching their nuts whilst ignoring your interjection--",
                        ];

                        const reply = responses[Math.floor(Math.random() * responses.length)];
                        updateBattleLog(`${responder.name}: ${reply}`);
                    }

                    render();
                    return;
                }

                // ======== Persuasion During Combat ========
                const baseChance = 0.1;
                const prsBonus = player.persuasion * 0.03;
                const totalChance = Math.min(0.9, baseChance + prsBonus);

                if (Math.random() < totalChance) {
                    const newAlly = {
                        name: currentEnemy.name,
                        hp: Math.floor(currentEnemy.hp / 2),
                        healedThisBattle: false
                    };
                    party.push(newAlly);
                    updateBattleLog(`<span class="PRS">${currentEnemy.name}</span> is now following your trail of sweat.`);
                    player.inCombat = false;
                    currentEnemy = null;
                    playMusic('exploration');
                } else {
                    updateBattleLog(`${currentEnemy.name} really, quite genuinely, does not care...`);
                    enemyAttack();
                }

                render();
            }
        });



        function handleLevelUpInput(key) {
            switch (key) {
                case 'h':
                    player.maxHp += 5;
                    break;
                case 'd':
                    player.defense += 2;
                    break;
                case 'p':
                    player.persuasion += 2;
                    break;
                default:
                    return;
            }
            player.hp = player.maxHp;
            player.exp = 0;
            player.levelingUp = false;
            render();
        }

        function useItem(itemName) {
            items[itemName].use();

            player.inventory[itemName]--;
            if (player.inventory[itemName] <= 0) {
                delete player.inventory[itemName];
            }
        }

        function getArticle(noun) {
            if (noun.match(/^\w*s\b|\barmor$/i)) {
                return '';
            }

            return ['a', 'e', 'i', 'o', 'u'].includes(noun.substr(0, 1).toLowerCase()) ? 'an ' : 'a ';
        }

        function gamble() {
            player.bitcoins -= gambler.playPrice;
            updateBattleLog(`You hand the gambler <span class="tooExpensive">${gambler.playPrice} BTC</span>. Let's hope it was worth it`);

            player.inputDisabled = true;
            document.getElementById('menu').classList.add('hidden');

            dice = [
                Math.floor(Math.random() * 6) + 1,
                Math.floor(Math.random() * 6) + 1,
            ];
            gambleAnimation(dice, () => {
                player.inputDisabled = false;
                gambleOutcome(dice);
            });
            playSFX('gamble');
        }

        function gambleOutcome(dice) {
            const sum = dice[0] + dice[1];
            const win = sum === 12;
            const sumClass = win ? 'friendly' : 'enemy';

            let html = 'You rolled a ' +
                `<span class="gambler">${dice[0]}</span> and a ` +
                `<span class="gambler">${dice[1]}</span> ` +
                `for a sum of <span class="${sumClass}">${sum}</span>\n\n`;

            if (win) {
                const stats = ['hp', 'defense', 'persuasion'];
                const randomStat = stats[Math.floor(Math.random() * stats.length)];

                switch (randomStat) {
                    case 'hp':
                        // Get a bonus of either 5 or 10 HP
                        const healthBoost = 5 + (Math.floor((Math.random() * 2)) * 5)
                        player.hp += healthBoost;
                        player.maxHp += healthBoost;
                        updateBattleLog(`<span class="LV">You scored a health boost! +${healthBoost} HP!</span>`);
                        break;
                    case 'defense':
                        // Get a bonus of either 1 or 2 defense
                        const defenseBoost = 1 + Math.floor((Math.random() * 2));
                        player.defense += defenseBoost;
                        updateBattleLog(`<span class="LV">You won a defense boost! +${defenseBoost} DEF!</span>`);
                        break;
                    case 'persuasion':
                        // Get a bonus of either 1 or 2 persuasion
                        const persuasionBoost = 1 + Math.floor((Math.random() * 2));
                        player.persuasion += persuasionBoost;
                        updateBattleLog(`<span class="LV">You won a persuasion boost! +${persuasionBoost} PRS!</span> (Actually the gambler just handed you a beat-up copy of "How to Win Friends and Influence People", but whatever)`);
                        break;
                }
            } else {
                gambler.say('Hah! Tough luck, kid!');
            }

            menu.close();
        }

        /**
         * This animates the hand throwing dice when gambling
         *
         * The animation works by calling the gambleFrames in sequence. The
         * number of defined frames is actually more than the number of the
         * available frames in the animation. This is because the final frame is
         * held and displays random digits to emphasize the roll
         */
        function gambleAnimation(dice, callback, frame) {
            const maxFrames = 24;
            const frameNumber = frame || 0;
            const displayFrame = Math.min(frameNumber, gambleFrames.length - 1);
            const isFinalFrame = frameNumber >= maxFrames - 1;

            if (frameNumber === 0) {
                document.getElementById('animation').classList.remove('hidden');
                document.getElementById('menu').classList.add('hidden');
            }

            // Set random dice digits before displaying the actual outcome
            const d = isFinalFrame ? dice : [
                Math.floor(Math.random() * 6) + 1,
                Math.floor(Math.random() * 6) + 1,
            ];

            if (frameNumber < maxFrames) {
                // Add some padding to center the animation
                let frameText = gambleFrames[displayFrame].replace(/^/gm, '       ');
                if (frameNumber >= gambleFrames.length - 4) {
                    // Draw digits on the bones
                    frameText = frameText.replace(
                        /(^[ |]+\n^ +\|   ) {5}( +\| +\|   ) {5}(.+\n^ +\|   ) {5}( +\| +\|   ) {5}(.+\n^ +\|   ) {5}( +\| +\|   ) {5}/m,
                        `$1${dieDigit[d[0] - 1][0]}$2${dieDigit[d[1] - 1][0]}$3${dieDigit[d[0] - 1][1]}$4${dieDigit[d[1] - 1][1]}$5${dieDigit[d[0] - 1][2]}$6${dieDigit[d[1] - 1][2]}`,
                    );
                }

                document.getElementById("animation").textContent = frameText;
                setTimeout(() => gambleAnimation(dice, callback, frameNumber + 1), !isFinalFrame ? 50 : 3000);
            } else {
                document.getElementById('animation').classList.add('hidden');
                document.getElementById('menu').classList.remove('hidden');
                typeof callback === 'function' && callback();
            }
        }

        function handleLevelUpInput(key) {
            if (key === 'h') {
                player.maxHp += 5;
            } else if (key === 'd') {
                player.defense += 1;
            } else if (key === 'p') {
                player.persuasion += 1;
            } else {
                return; // Ignore other keys
            }

            // Now level up properly when the player manually chooses to level up
            player.level++;
            player.exp = 0; // Reset EXP after leveling up
            player.hp = player.maxHp; // Fully heal the player
            player.levelingUp = false; // Reset leveling up state

            updateBattleLog(`<span class="LV">Oh... you leveled up. Whatever dude.</span>`);
            render();
        }



        document.addEventListener('keydown', e => {
            if (player.inputDisabled || gameOver || awaitingPersuasionText) {
                return;
            }

            const key = e.key.toLowerCase();

            if (menu.isOpen()) {
                menu.handleInput(key);
            } else if (player.levelingUp) {
                handleLevelUpInput(key);
                return; // <-- this fixes it
            } else if (key === 'i') {
                playSFX('inventoryOpen');
                menu.open('inventory');
            } else if (player.inCombat) {
                // Combat mode
                switch (key) {
                    case 'a':
                        playerAttack();
                        break;
                    case 'r':
                        tryRun();
                        break;
                    case 'p':
                        tryPersuade(e);
                        break;
                }
            } else {
                // Exploration mode
                switch (key) {
                    case 'w':
                    case 'arrowup':
                        move('forward');
                        break;
                    case 's':
                    case 'arrowdown':
                        move('backward');
                        break;
                    case 'a':
                    case 'arrowleft':
                        turnLeft();
                        break;
                    case 'd':
                    case 'arrowright':
                        turnRight();
                        break;
                    case 't':
                        speakingOutsideCombat = true;
                        tryPersuade(e);
                        break;
                }
            }

            render();
        });



        function descend() {
            floor++;
            updateBattleLog(`Descending into floor ${floor}...`);

            const floorBoost = Math.floor(floor / 2);
            if (floorBoost > lastFloorBoostNotice) {
                updateBattleLog(`<span class="action">As you descend deeper into the dungeon, you sense greater danger than before</span>.`);
                lastFloorBoostNotice = floorBoost;
            }

            if (Math.random() < 0.5) {
                const flavorText = [
                    "The stale air fills your nostrils.",
                    "You feel like you're being watched.",
                    "A chill creeps down your spine.",
                    "Your torch flickers strangely in the windless corridor.",
                    "A draft carries the scent of mildew, ash, and Lemon Pledge.",
                    "You hear a dog yipping in the distance.",
                    "An empty snail shell lies cracked on the stairs.",
                    "A growl echoes through the hallway.",
                    "A faint smell of urinal cake wafts up from below.",
                    "You hear a toilet flush in the distance.",
                    "There's graffiti on the wall: \"Beware the snail!\"",
                    "You smell something pungent. Possibly ancient evil. Possibly cheese.",
                    "You hear a groan, as if the dungeon itself is aware of your presence.",
                    "Somewhere ahead, something clanks. You sincerely hope it's plumbing.",
                    "You hear a plunger plunging menacingly.",
                ];

                const logLine = flavorText[Math.floor(Math.random() * flavorText.length)];
                updateBattleLog(logLine);
            }

            generateMap();
        }


        generateMap();
        playMusic('exploration');
        render();
        let musicEnabled = true;

        document.getElementById('musicToggle').addEventListener('click', () => {
            musicEnabled = !musicEnabled;
            const btn = document.getElementById('musicToggle');
            btn.textContent = musicEnabled ? "Toggle Music" :
                "Toggle Music";

            for (let key in music) {
                music[key].muted = !musicEnabled;
                if (!musicEnabled) {
                    music[key].pause();
                } else if (currentMusic) {
                    music[currentMusic].play().catch(err => console.error(
                        "Music play error:", err));
                }
            }
        });

        const menu = {
            breadcrumbs: [],
            selectionIndex: 0,
            getActiveMenu: () => menu.menus[menu.breadcrumbs.at(-1)?.menuName] || undefined,
            isOpen: () => menu.breadcrumbs.length > 0,
            open: (menuName) => {
                if (typeof menu.menus[menuName] === 'undefined') {
                    console.error('No matching entry for the designated menu name', { menuName });
                    return;
                }

                const activeMenu = menu.menus[menuName];

                menu.breadcrumbs.push({
                    menuName,
                    selectionIndex: menu.selectionIndex,
                });

                // Put the cursor on the first non-disabled option, if available
                menu.selectionIndex = Math.max(activeMenu.getOptions().findIndex((e) => !e.disabled), 0);

                document.getElementById('game').classList.add('hidden');
                document.getElementById('menu').classList.remove('hidden');
                document.getElementById('menuSelectionDescription').textContent = '';

                activeMenu.onOpen?.();
                menu.render();
            },
            close: () => {
                const previousMenu = menu.breadcrumbs.pop();
                menu.menus[previousMenu.menuName].onClose?.();
                menu.selectionIndex = previousMenu.selectionIndex;

                if (menu.breadcrumbs.length === 0) {
                    document.getElementById('menu').classList.add('hidden');
                    document.getElementById('game').classList.remove('hidden');
                }
            },
            render: () => {
                let menuHtml = "";
                const activeMenu = menu.getActiveMenu();
                if (typeof activeMenu === 'undefined') {
                    return;
                }

                const titleHtml = activeMenu.title ? `<span class="title">「${activeMenu.title}」</span>` : '';
                const landingHtml = `<div>${activeMenu.landingHtml() || ''}</div>`;
                document.getElementById('menuLanding').innerHTML = titleHtml + landingHtml;

                const options = activeMenu.getOptions();
                const trailTextMaxLength = Math.max(...options.map((o) => (o?.trailText || '').length));

                options.forEach((option, index) => {
                    const isSelectedLine = index === menu.selectionIndex;
                    const cursor = isSelectedLine ? "▶ " : "  ";
                    const spanHtml = option.className ? `<span class="${option.className}">` : '<span>';
                    let line = '';

                    if (option.hasOwnProperty('trailText')) {
                        const dotPattern = option.displayText.length % 2 ? ' .' : '. ';
                        const trailDiff = trailTextMaxLength - option.trailText.length;

                        line = (option.displayText + dotPattern.repeat(17 + Math.floor(trailDiff / 2))).substr(0, 34 + trailDiff) +
                            ` ${option.trailText}`;
                    } else {
                        line = `${option.displayText}`;
                    }

                    menuHtml += `${cursor}${spanHtml}${line}</span>\n`;

                    if (isSelectedLine) {
                        document.getElementById('menuSelectionDescription').textContent = option.description;
                    }
                });

                document.getElementById('menuList').innerHTML = menuHtml;
            },
            handleInput: (key) => {
                const activeMenu = menu.getActiveMenu();
                const options = activeMenu.getOptions();

                switch (key) {
                    case 'escape':
                        menu.close();
                        playSFX('uiCancel');
                        break;
                    case 'w':
                    case 'arrowup':
                        menu.selectionIndex = menu.selectionIndex === 0
                            ? options.length - 1
                            : menu.selectionIndex - 1;
                        playSFX('uiOption');
                        break;
                    case 's':
                    case 'arrowdown':
                        menu.selectionIndex = menu.selectionIndex === options.length - 1
                            ? 0
                            : menu.selectionIndex + 1;
                        playSFX('uiOption');
                        break;
                    case ' ':
                    case 'e':
                    case 'enter':
                        if (options[menu.selectionIndex].disabled) {
                            playSFX('uiCancel');
                            break;
                        }

                        const selectedOptionId = options[menu.selectionIndex].id;
                        if (selectedOptionId === '_exit') {
                            menu.close();
                            playSFX('uiCancel');
                        } else {
                            activeMenu.select(selectedOptionId);
                            playSFX('uiSelect');
                        };
                        break;
                }

                menu.render();
            },
            menus: {
                inventory: {
                    title: "INVENTORY",
                    landingHtml: () => {
                        return isEmpty(player.inventory)
                            ? 'You own nothing. Klaus Schwab would be proud'
                            : null;
                    },
                    getOptions: () => {
                        const options = Object.keys(player.inventory).map((itemId) => ({
                            id: itemId,
                            displayText: items[itemId].name,
                            description: items[itemId].description,
                            trailText: `${player.inventory[itemId]}x`,
                        }));

                        options.push({
                            id: "_exit",
                            displayText: "Exit the Inventory",
                            description: "Get back to playing the game",
                        });

                        return options;
                    },
                    select: (selectedOptionId) => {
                        useItem(selectedOptionId);
                        menu.close();
                        if (currentEnemy && currentEnemy.hp > 0) {
                            enemyAttack();
                            render();
                        }
                    },
                },
                merchant: {
                    title: "MERCHANT",
                    onOpen: () => {
                        merchant.say('Welcome to SlobMart!');
                    },
                    onClose: () => {
                        merchant.say('Thank you. Come again!');
                    },
                    landingHtml: () => {
                        return player.bitcoins > 0
                            ? `You have <span class="BTC">${player.bitcoins} BTC</span> in your wallet`
                            : "Your wallet is emptier than a lughead's skull. But you can still look around";
                    },
                    getOptions: () => {
                        return [
                            {
                                id: "merchantItems",
                                displayText: "Items",
                                description: "See what consumable items are for sale",
                            },
                            {
                                id: "merchantWeapons",
                                displayText: "Weapons",
                                description: "Look at some weapon upgrades",
                            },
                            {
                                id: "merchantArmor",
                                displayText: "Armor",
                                description: "Get some thicker skin",
                            },
                            {
                                id: "_exit",
                                displayText: "Leave",
                                description: "Get back to spelunking",
                            },
                        ];
                    },
                    select: (selectedOptionId) => {
                        menu.open(selectedOptionId);
                    },
                },
                merchantItems: {
                    title: "MERCHANT",
                    landingHtml: () => {
                        return player.bitcoins > 0
                            ? `You have <span class="BTC">${player.bitcoins} BTC</span> in your wallet`
                            : "Your wallet is emptier than a lughead's skull. But you can still look around";
                    },
                    getOptions: () => {
                        const options = merchant.items.map((itemId) => ({
                            id: itemId,
                            displayText: items[itemId].name,
                            description: items[itemId].description,
                            trailText: `${items[itemId].price} BTC`,
                            disabled: items[itemId].price > player.bitcoins,
                            className: items[itemId].price > player.bitcoins ? 'tooExpensive' : undefined,
                        }));

                        options.push({
                            id: "_exit",
                            displayText: "Back",
                            description: "Return to the merchant menu",
                        });

                        return options;
                    },
                    select: (selectedOptionId) => {
                        merchant.buy('item', selectedOptionId);
                    },
                },
                merchantWeapons: {
                    title: "MERCHANT",
                    landingHtml: () => {
                        const message = player.bitcoins > 0
                            ? `You have <span class="BTC">${player.bitcoins} BTC</span> in your wallet`
                            : "Your wallet is emptier than a lughead's skull. But you can still look around";

                        const currentWeapon = weapons[player.weapon].name;
                        const currentWeaponDisplay = getArticle(currentWeapon) + currentWeapon;
                        const wieldingMessage = `You are currently wielding ${currentWeaponDisplay}`;

                        return `${message}\n\n${wieldingMessage}`;
                    },
                    getOptions: () => {
                        const weaponKeys = Object.keys(weapons);
                        const options = weaponKeys.map((weaponId) => {
                            const tooExpensive = weapons[weaponId].price > player.bitcoins;
                            const notAnUpgrade = weaponKeys.indexOf(player.weapon) >= weaponKeys.indexOf(weaponId);

                            return {
                                id: weaponId,
                                displayText: weapons[weaponId].name,
                                description:
                                    `${weapons[weaponId].description}\n` +
                                    `Base Damage: ${weapons[weaponId].damage.base}, ` +
                                    `Random Multiplier: ${weapons[weaponId].damage.randomMultiplier}`,
                                trailText: `${weapons[weaponId].price} BTC`,
                                disabled: tooExpensive || notAnUpgrade,
                                className: notAnUpgrade ? 'muted' : (tooExpensive ? 'tooExpensive' : undefined),
                            };
                        });

                        options.push({
                            id: "_exit",
                            displayText: "Back",
                            description: "Return to the merchant menu",
                        });

                        return options;
                    },
                    select: (selectedOptionId) => {
                        merchant.buy('weapon', selectedOptionId);
                    },
                },
                merchantArmor: {
                    title: "MERCHANT",
                    landingHtml: () => {
                        const message = player.bitcoins > 0
                            ? `You have <span class="BTC">${player.bitcoins} BTC</span> in your wallet`
                            : "Your wallet is emptier than a lughead's skull. But you can still look around";

                        const currentArmor = armor[player.armor].name;
                        const currentArmorDisplay = getArticle(currentArmor) + currentArmor;
                        const wearingMessage = `You are currently wearing ${currentArmorDisplay}`;

                        return `${message}\n\n${wearingMessage}`;
                    },
                    getOptions: () => {
                        const armorKeys = Object.keys(armor);
                        const options = armorKeys.map((armorId) => {
                            const tooExpensive = armor[armorId].price > player.bitcoins;
                            const notAnUpgrade = armorKeys.indexOf(player.armor) >= armorKeys.indexOf(armorId);

                            return {
                                id: armorId,
                                displayText: armor[armorId].name,
                                description:
                                    `${armor[armorId].description}\n` +
                                    `Defense: ${armor[armorId].defense}`,
                                trailText: `${armor[armorId].price} BTC`,
                                disabled: tooExpensive || notAnUpgrade,
                                className: notAnUpgrade ? 'muted' : (tooExpensive ? 'tooExpensive' : undefined),
                            };
                        });

                        options.push({
                            id: "_exit",
                            displayText: "Back",
                            description: "Return to the merchant menu",
                        });

                        return options;
                    },
                    select: (selectedOptionId) => {
                        merchant.buy('armor', selectedOptionId);
                    },
                },
                gambler: {
                    title: "GAMBLER",
                    onOpen: () => {
                        gambler.say('Place yer bets!');
                    },
                    onClose: () => {
                        gambler.say('You gotta know when to hold \'em, know when to fold \'em, heh heh');
                        updateBattleLog('The gambler escapes into the shadows');

                        gambler.isActiveOnFloor = false;
                    },
                    landingHtml: () => {
                        return (
                            `<span class="gambler">&lt;GAMBLER&gt;</span> "Welcome, dungeon dweller! ` +
                            `<span class="friendly">Roll a 12</span> and <span class="BTC">boost one of yer stats.</span> ` +
                            `Just <span class="tooExpensive">${gambler.playPrice} BTC</span> to play!"\n\n` +
                            `You have <span class="BTC">${player.bitcoins} BTC</span> in your wallet`
                        );
                    },
                    getOptions: () => {
                        return [
                            {
                                id: "play",
                                displayText: "Play the game",
                                trailText: `${gambler.playPrice} BTC`,
                                description: "Take your chance with the gambler",
                            },
                            {
                                id: "_exit",
                                displayText: "Leave",
                                description: "Leave this crusty fool",
                            },
                        ];
                    },
                    select: () => {
                        gamble();
                    },
                },
            },
        };

        const gambleFrames = [
    `



                  _____
                 /     -.
                 \\____.--


    `,

    `



              _,--.
             ( ;.  \`-.
             (  '    _
              \`-___-'

    `,

    `



           _,-.-.
          (_;.   \`-.
         (__:
          (__.'    _
           \`-____-'

    `,

    `


       _,-.-.
      (_;.   \`-.
      (__:
      (__'
      (__.'    _
       \`-____-'

    `,

    `


     _,--.---.
    (_;-.__   \`-.
    (______)
    (______)
    (_____)     _
     \`-_______-'
    `,

    `

          ____
     ____'._  '.
    (____)_ \`.  \`-.
    (______)\\
     (______)
      (_____)     _
       \`-_______-'

    `,

    `

            ..__
    ________\`.  '-
   (__)______ \`.  '-.
    (__)__/_\\
      (____)
       (___)        _
         \`-_______-'

    `,

    `

              ..__
    __________\`.  '-
   (___________ \`.  '-.
    (______..--.
      (__)_||__|
        (_)_          _
           \`-_______-'

    `,

    `

                ..__
      __________\`.  '-
     (___________ \`.  '-.
      (___/_/\\ ___.
       (__\\_\\/|   ||
         (____|___||    _
              \`-______-'

    `,

    `

                  ..__
        __________\`.  '-
       (___________ \`.  '-.
        (__________
         (________
         .-'--._ .----_   _
         | |  | |\` ___'.-'
         \`.|..' ' \`    |
                 \`|____'

    `,

    `

                      ..__
            __________\`.  '-
           (___________ \`.  '-.
            (__________
             (________
               (____          _
                    \`-______-'
       .-----       .----.
      / \`.   \`.    /      \\
     /    '.___\`. /________\\
     \`.   /    /  \\        /
       \`./____/    \\      /
                    \`----'
    `,

    `

                          ..__
                __________\`.  '-
               (___________ \`.  '
                (__________
                 (________
                   (____
                        \`-______-


    .----------.   .----------.
    |          |   |          |
    |          |   |          |
    |          |   |          |
    |          |   |          |
    |__________|   |__________|
    `,

    `


                         _________
                        (_________
                          (_______
                           (______
                             (____



    .----------.   .----------.
    |          |   |          |
    |          |   |          |
    |          |   |          |
    |          |   |          |
    |__________|   |__________|
    `,

    `


                                 _
                                (_






    .----------.   .----------.
    |          |   |          |
    |          |   |          |
    |          |   |          |
    |          |   |          |
    |__________|   |__________|
    `,

    `










    .----------.   .----------.
    |          |   |          |
    |          |   |          |
    |          |   |          |
    |          |   |          |
    |__________|   |__________|
    `,

];

    const dieDigit = [
        ['▗▄▋  ', ' ▐▋  ', '▝▀▀▘ '], // 1
        ['▄▀▀▄ ', ' ▄▀  ', '▀▀▀▀▘'], // 2
        ['▄▀▀▄ ', '  ▀▄ ', '▀▄▄▀ '], // 3
        ['█  █ ', '▀▀▀█ ', '   ▀ '], // 4
        ['█▀▀▀ ', '▀▀▀▄ ', '▀▄▄▀ '], // 5
        ['▄▀▀▀ ', '█▀▀▄ ', '▀▄▄▀ '], // 6
    ];
    </script>


</body></html>